library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

-- running on board: Cyclone 5 GX Starter Kit 

entity Upscaler is	
	port (
	   -- default clocking and reset
		CLK50: in std_logic;	
      RST: in std_logic;

		-- on-board user IO
		LED: out STD_LOGIC_VECTOR(17 downto 0);
		HEX: out STD_LOGIC_VECTOR(13 downto 0);
		SWITCH: in STD_LOGIC_VECTOR(9 downto 0);
      KEY: in STD_LOGIC_VECTOR(3 downto 0);

	   -- HDMI interface
		SCL: inout std_logic; 
		SDA: inout std_logic; 
      adv7511_hs : out std_logic; 
      adv7511_vs : out std_logic;
      adv7511_clk : out std_logic;
      adv7511_d : out STD_LOGIC_VECTOR(23 downto 0);
      adv7511_de : out std_logic;

		-- ADC interface
		SCK: out std_logic; 
		SDI: out std_logic; 
		SEN: out std_logic; 
		MCLK: out std_logic; 
		RSMP: out std_logic; 
		VSMP: out std_logic; 
		OEB: out std_logic; 
      OP: in STD_LOGIC_VECTOR(7 downto 0);
		SYNC: in std_logic;
		
		-- UART to send data to PC
		TX : out std_logic
	);	
end entity;


architecture immediate of Upscaler is

   component PLL_90 is
	port (
		refclk   : in  std_logic; --  refclk.clk
		rst      : in  std_logic; --   reset.reset
		outclk_0 : out std_logic  -- outclk0.clk
	);
   end component;

   component PLL_216 is
   port (
		refclk   : in  std_logic := '0'; --  refclk.clk
		rst      : in  std_logic := '0'; --   reset.reset
		outclk_0 : out std_logic        -- outclk0.clk
	);
   end component;
	component SampleBuffer IS
	port
	(
		data		: IN STD_LOGIC_VECTOR (9 DOWNTO 0);
		rdaddress		: IN STD_LOGIC_VECTOR (10 DOWNTO 0);
		rdclock		: IN STD_LOGIC ;
		wraddress		: IN STD_LOGIC_VECTOR (10 DOWNTO 0);
		wrclock		: IN STD_LOGIC  := '1';
		wren		: IN STD_LOGIC  := '0';
		q		: OUT STD_LOGIC_VECTOR (9 DOWNTO 0)
	);
   end component;
	component VideoRam IS
	port
	(
		address_a		: IN STD_LOGIC_VECTOR (18 DOWNTO 0);
		address_b		: IN STD_LOGIC_VECTOR (18 DOWNTO 0);
		clock_a		: IN STD_LOGIC  := '1';
		clock_b		: IN STD_LOGIC ;
		data_a		: IN STD_LOGIC_VECTOR (7 DOWNTO 0);
		data_b		: IN STD_LOGIC_VECTOR (7 DOWNTO 0);
		wren_a		: IN STD_LOGIC  := '0';
		wren_b		: IN STD_LOGIC  := '0';
		q_a		: OUT STD_LOGIC_VECTOR (7 DOWNTO 0);
		q_b		: OUT STD_LOGIC_VECTOR (7 DOWNTO 0)
	);
   end component;

	
	signal clksample8x : std_logic;      -- 216 MHz clock to drive the ADC
	signal clksample : std_logic;        -- 27 Mhz clock for processing logic
	signal clkpixel : std_logic;         -- pixel clock to drive HDMI 
	
	signal rawsample : STD_LOGIC_VECTOR(7 downto 0);    -- sample before level adjustment
	signal inputsample : STD_LOGIC_VECTOR(7 downto 0);  -- sample currently incomming
	signal delaynextsample : integer range 0 to 7;      -- how much the next sample should be delayed
	signal framestart : std_logic;
	
	signal sample_write_data : STD_LOGIC_VECTOR (9 DOWNTO 0);
	signal sample_write_address: STD_LOGIC_VECTOR(10 downto 0);
	signal sample_read_address: STD_LOGIC_VECTOR(10 downto 0);
	signal sample_data: STD_LOGIC_VECTOR(9 downto 0);

	signal video_address_a: STD_LOGIC_VECTOR(18 downto 0);
	signal video_address_b: STD_LOGIC_VECTOR(18 downto 0);
 	signal video_data_a : STD_LOGIC_VECTOR (7 DOWNTO 0);
	signal video_wren_a : STD_LOGIC;
	signal video_q_a : STD_LOGIC_VECTOR(7 downto 0);
	signal video_q_b : STD_LOGIC_VECTOR(7 downto 0);	

begin		
	pixelclockgenerator: PLL_90	port map (CLK50, '0', clkpixel);
	sampleclockgenerator: PLL_216	port map (CLK50, '0', clksample8x);
   samplebuffer1 : SampleBuffer port map(sample_write_data, sample_read_address, clkpixel, 
	   sample_write_address, clksample, '1', sample_data);
   videoram1 : VideoRam port map(video_address_a, video_address_b, 
	                              clksample,clkpixel, 
	                              video_data_a, "00000000",
											video_wren_a, '0',
											video_q_a, video_q_b);
		
	-- read individual sample from the ADC and generate the sample clock 
	process (clksample8x)		
	type state_type is (s0,s1,s2,s3,s4,s5,s6,s7);
	variable state : state_type := s7;
	variable delay : integer range 0 to 7;
	variable in_data : std_logic_vector(7 downto 0);
	variable out_data : std_logic_vector(7 downto 0);
	variable out_mclk : std_logic := '0';
	variable out_vsmp : std_logic := '0';	
	begin	
   	if rising_edge(clksample8x) then
			out_data := in_data;
		
			-- compute new state and output values
			case state is
			when s7 =>
			   delay := delaynextsample;
			   state := s0;
				out_mclk := '1';
				out_vsmp := '0';
				in_data := OP;
		   when  s0 => 
			   if delay=0 then
  				   state := s1;
				else 
				   delay := delay-1;
				end if;
			   out_mclk := '1';
			   out_vsmp := '0';				
		   when  s1 => 
				state := s2;
				out_mclk := '1';
				out_vsmp := '0';
		   when  s2 => 
				state := s3;
				out_mclk := '1';
				out_vsmp := '1';
		   when  s3 => 
				state := s4;
				out_mclk := '0';
				out_vsmp := '1';
			when  s4 => 
				state := s5;
				out_mclk := '0';
				out_vsmp := '1';
			when  s5 => 
				state := s6;
				out_mclk := '0';
				out_vsmp := '1';
			when  s6 => 
				state := s7;
				out_mclk := '0';
				out_vsmp := '0';
			end case;

		end if;
		
		MCLK <= out_mclk;
		RSMP <= '0';
		VSMP <= out_vsmp;
		
		rawsample <= out_data;
		clksample <= out_mclk;
	end process;

	
   -- process the raw samples to auto-adjust the level 
	process (clksample)		
	variable akku : unsigned (25 downto 0);
	variable in_sample : unsigned (7 downto 0);
	variable out_sample : unsigned (7 downto 0);
	variable baseline : unsigned (7 downto 0);
	begin	
		if rising_edge(clksample) then
			in_sample := unsigned(rawsample);
			baseline := akku (25 downto 18) - to_unsigned(8,8); 
			if in_sample < baseline then
				out_sample := "00000000";
			else
				out_sample := in_sample - baseline;
			end if;
			
         if in_sample < akku(25 downto 18) then
				akku := akku - to_unsigned(64,26);
			else
			   akku := akku + to_unsigned(1,26);
			end if;
		end if;
		
		inputsample <= std_logic_vector(out_sample);
	end process;	

	
   -- collect the raw samples into the diagnosis buffer 
	process (clksample,inputsample)		
	variable counter : unsigned(10 downto 0) := (others => '0');
	begin	
		if rising_edge(clksample) then
		   if RST='0' or KEY(0)='1' then
			   counter := (others => '0');
			else         
				if counter = "11111111111" then
	   	        -- stop counter
	   	   else 
	   	      counter := counter + 1;
  			   end if;
			end if;			
		end if;
		
		sample_write_data <= "00" & rawsample;
		sample_write_address <= std_logic_vector(counter);

	end process;	
	
	
   -- read video signal and fill data in video ram
	process (clksample)		
	variable synclength : integer range 0 to 2000 := 0;
	variable topoverscan : integer range 0 to 100 := 0;
	variable pixelvalue : unsigned(7 downto 0) := (others => '0');
	variable x : integer range 0 to 4093 := 0;
	variable y : integer range 0 to 255 := 0;
	variable v : integer range 0 to 255 := 0;
	variable v_prev : integer range 0 to 255 := 0;
	variable xp : integer range 0 to 1619 := 0;
	
	variable outputmode : std_logic := '0';
	variable outputaddress : integer range 0 to 1620*256-1;
	variable outputbit : integer range 0 to 9;
	variable outputbitcounter : integer range 0 to 1023; 
	
	variable out_framestart : std_logic := '0';
	variable out_delaynextsample : integer range 0 to 7;
	variable out_tx : std_logic;
	
	begin	
		if rising_edge(clksample) then
		  if RST='0' then
			   synclength := 0;
				topoverscan := 0;
				pixelvalue := (others => '0');
			   x := 0;
			   y := 0;
			   xp := 0;
				
		  else 
		   v_prev := v;
  	      v := to_integer(unsigned(inputsample));
			out_delaynextsample := 0;
			
			if x<0 then
			   xp := 0;
			elsif x>=1620 then
		      xp := 1619;
			else 
			   xp := x;
			end if;
							
			
			-- count length of sync
			if v<32 then
			   synclength := synclength + 1;
	  			if x<4093 then
				   x := x+1;
				end if;
				
	         pixelvalue := (others => '0');
				
			-- detect end of sync (ignore small glitches)
         elsif synclength > 5 then
			   x := 0;
				
			   -- this was vsync
				if synclength > 250 then
				   y := 0;
					topoverscan := 0;
					if KEY(1)='0' then
					   outputmode := '1';
						outputaddress := 0;
						outputbit := 0;
						outputbitcounter := 0;
					end if;
				elsif topoverscan<33 then
				   topoverscan := topoverscan+1;
				elsif y<255 then
				   y := y+1;
				end if;

				synclength := 0;
	         pixelvalue := (others => '0');
			
			   out_delaynextsample := (8 * (32-v_prev)) / (v-v_prev);
			-- normal image 
			else 
				if x<4093 then
				   x := x+1;
				end if;
					
				synclength := 0;
								
				if v < 64 then
				   pixelvalue := (others => '0');
				elsif v >= 192 then
				   pixelvalue := (others => '1');
				else
				   pixelvalue := to_unsigned(2 * (v-64), 8);
			   end if;	
			end if;

		  -- detect frame start and notify the HDMI signal generator
		  if y>=1 and y<10 then
   		  out_framestart := '1';
		  else
		     out_framestart := '0';
		  end if;

         -- mode for sending data to the uart
			if outputmode='0' then
			   out_tx := '1';
		   else
			   if outputbitcounter<(27000000/230400)-1 then 
				   outputbitcounter:=outputbitcounter+1;
				else 
				   outputbitcounter:=0;
					if outputbit<9 then
					   outputbit:=outputbit+1;
					else 
					   outputbit:=0;
						if outputaddress < 1620*256-1 then
						   outputaddress := outputaddress+1;
						else
						   outputmode := '0';
					   end if;
					end if;
				end if;
				if outputbit<1 then
					out_tx := '0';
				elsif outputbit>8 then 
					out_tx := '1';
				else
					out_tx := video_q_a(outputbit-1);
				end if;
			end if;
			
		  end if;  -- RST   
		end if;   -- rising_edge
		
		delaynextsample <= out_delaynextsample;
		framestart <= out_framestart;
		TX <= out_tx;
		
		if outputmode='0' then
			video_address_a <= std_logic_vector(to_unsigned(y*1620+xp,19));
			video_data_a 	<= std_logic_vector(pixelvalue);
			video_wren_a   <= '1';
		else 
			video_address_a <= std_logic_vector(to_unsigned(outputaddress,19));
			video_data_a   <= "00000000";
			video_wren_a   <= '0';
		end if;
		
	end process;	
	
	
	-- create the hdmi video signals 
	process (clkpixel) 
	 -- timings for XSGA
	constant h_sync : integer := 112;
	constant h_bp : integer := 248;
	constant h_fp : integer := 48 + 32;
	constant h_total : integer := h_sync + h_bp + 1280 + h_fp;
	constant v_sync : integer := 3;
	constant v_bp : integer := 1;
	constant v_fp : integer := 38;
	constant v_total : integer := v_sync + v_bp + 1024 + v_fp;
	
	variable x : integer range 0 to h_total := 0; 
	variable y : integer range 0 to v_total := 0;
	
   variable out_hs : std_logic;
	variable out_vs : std_logic;
	variable out_white : unsigned (7 downto 0);
	variable out_de : std_logic;
	
	variable tmp_x : integer range 0 to h_total-1;
	variable tmp_y : integer range 0 to v_total-1;
	variable tmp_y_us : unsigned(7 downto 0);
	variable tmp_data : unsigned(7 downto 0);

	variable speedup : integer range 0 to 63 := 32;
	variable in_framestart : std_logic;
	variable prev_framestart : std_logic;
	
	begin
		if rising_edge(clkpixel) then
		   -- request next output sample
         sample_read_address <= std_logic_vector(to_unsigned(x,11));			
		
         -- write output signals to registers 
			if y<v_sync then
				out_vs := '1';
			else 
			   out_vs := '0';
			end if;
			if x<h_sync then
				out_hs := '1';
			else 
			   out_hs := '0';
			end if;
   	
			
			tmp_x := x+3-(h_sync+h_bp);
			tmp_y := y-(v_sync+v_bp);				

			-- request video data for next pixel
		   video_address_b <= std_logic_vector(to_unsigned((tmp_y/4)*1620+tmp_x+210,19));
				
			-- determine the color according to the sample info
			if y>=v_sync+v_bp and y<v_total-v_fp and
			   x>=h_sync+h_bp and x<h_total-h_fp then

				out_de := '1';
				out_white := unsigned(video_q_b);
				
				-- top part of screen can be overlaid with diagnosis output
			   if tmp_y <= 255 and KEY(0)='0'then
					tmp_data := unsigned(sample_data(7 downto 0));
					tmp_y_us := to_unsigned(tmp_y, 8);
					if to_integer(tmp_data)-2 <= 255-tmp_y and 
					   to_integer(tmp_data)+2 >= 255-tmp_y
					then
	 			       out_white := "11110000";					
					else
						out_white := "0000" & tmp_y_us(5) & "000";
					end if;
				end if;
			else
     		   out_de := '0';
			   out_white := (others=>'0');
			end if;
			
			
			-- continue with next pixel in next clock
			if RST='0' then
				x := 0;
				y := 0;
			 elsif x < (h_total-1) - speedup then
				x := x+1;
			 else 
				-- detect start of input frame and adjust speed to sync with it
				prev_framestart := in_framestart;
				in_framestart := framestart;
				if in_framestart='1' and prev_framestart='0' then
					if tmp_y>=932 then 
					   speedup := 0;	
               elsif tmp_y<=900-31 then
					   speedup := 63;
					elsif tmp_y<900 then
					   speedup := 32 + 900 - tmp_y;
					else 
					   speedup := 32 - (tmp_y - 900);
					end if;
				end if;
				
				-- switch to next line
			   x := 0;
				if y >= v_total-1 then
				   y := 0;
				else
				   y := y+1;
				end if;
				
			 end if;
			 
		end if;
		
      adv7511_hs <= out_hs; 
      adv7511_vs <= out_vs;
      adv7511_clk <= not clkpixel;
      adv7511_de <= out_de;
      adv7511_d <= (std_logic_vector(out_white) & std_logic_vector(out_white) & std_logic_vector(out_white));
		
		LED <= std_logic_vector(to_unsigned(speedup,18));
	end process;
	
	
	
	-- send initialization data to HDMI driver via a I2C interface
	process (clksample)
	  constant initdelay:integer := 100;
	  -- data to be sent to the I2C slave
	  constant num:integer := 23;	  
	  type T_TRIPPLET is array (0 to 2) of integer range 0 to 255;
     type T_DATA is array(0 to num-1) of T_TRIPPLET;
     constant DATA : T_DATA := (
                    -- power registers
				(16#72#, 16#41#, 16#00#), -- power down inactive
				(16#72#, 16#D6#, 2#11000000#), -- HPD is always high
				
                    -- fixed registers
				(16#72#, 16#98#, 16#03#), 
				(16#72#, 16#9A#, 16#e0#), 
				(16#72#, 16#9C#, 16#30#),
				(16#72#, 16#9D#, 16#01#),
				(16#72#, 16#A2#, 16#A4#),
				(16#72#, 16#A3#, 16#A4#),
				(16#72#, 16#E0#, 16#D0#),
				(16#72#, 16#F9#, 16#00#),
				
				                 -- force to DVI mode
				(16#72#, 16#AF#, 16#00#),  

  				                 -- video input and output format
				(16#72#, 16#15#, 16#00#),        -- inputID = 1 (standard)
				                 -- 0x16[7]   = 0b0  .. Output format = 4x4x4
								     -- 0x16[5:4] = 0b11 .. color depth = 8 bit
									  -- 0x16[3:2] = 0x00 .. input style undefined
									  -- 0x16[1]   = 0b0  .. DDR input edge
									  -- 0x16[0]   = 0b0  .. output color space = RGB
				(16#72#, 16#16#, 16#30#),		
				
				                 -- various unused options - force to default
				(16#72#, 16#17#, 16#00#), 		
				(16#72#, 16#18#, 16#00#),  -- output color space converter disable 		
				(16#72#, 16#48#, 16#00#),
				(16#72#, 16#BA#, 16#60#),
				(16#72#, 16#D0#, 16#30#),
				(16#72#, 16#40#, 16#00#),
				(16#72#, 16#41#, 16#00#),
				(16#72#, 16#D5#, 16#00#),
				(16#72#, 16#FB#, 16#00#),
				(16#72#, 16#3B#, 16#00#)
	  );
	  -- divide down main clock to get slower state machine clock
	  constant clockdivider:integer := 2000;  	  
	  variable clockcounter: integer range 0 to clockdivider-1 := 0;

	  -- states of the machine
	  subtype t_state is integer range 0 to 11;
	  constant state_delay  : integer := 0;
	  constant state_idle   : integer := 1;
	  constant state_start0 : integer := 2;
	  constant state_start1 : integer := 3;
	  constant state_send0  : integer := 4;
	  constant state_send1  : integer := 5;
	  constant state_send2  : integer := 6;
	  constant state_ack0   : integer := 7;
	  constant state_ack1   : integer := 8;
	  constant state_ack2   : integer := 9;
	  constant state_stop0  : integer := 10;
	  constant state_stop1  : integer := 11;
	  variable state : t_state := state_delay;

	  variable delaycounter:integer range 0 to initdelay-1 := 0;
	  variable currentline: integer range 0 to num-1;
	  variable currentbyte: integer range 0 to 2 := 0; 
	  variable currentbit:  integer range 0 to 7 := 0;
	  
	  -- registers for the output signals
	  variable out_scl : std_logic := '1';
	  variable out_sda : std_logic := '1';

	  -- temporary
	  variable tmp8 : unsigned(7 downto 0);
	  variable tmptripplet : T_TRIPPLET;
	  
	  begin
		if rising_edge(clksample) then
		
			-- process reset
			if RST='0' then
            state := state_delay;
				delaycounter := 0;
			
         -- divide input clock to get slower state machine clock
 		   elsif clockcounter+1<clockdivider then
		      clockcounter := clockcounter+1;

			else
			   clockcounter := 0;
				
				case state is
				when state_delay =>
					if delaycounter < initdelay-1 then
					   delaycounter := delaycounter+1;
				   else 
					   state := state_start0;
						currentline := 0;
					end if;
				when state_start0 =>
				   state := state_start1;
					currentbyte := 0;
					currentbit := 7;
				when state_start1 =>
				   state := state_send0;
				when state_send0 =>
				   state := state_send1;
				when state_send1 =>
				   if SCL/='0' then  -- continue when not stretching the clock
					   state := state_send2;
				   end if;
			   when state_send2 =>
				   if currentbit > 0 then
					   currentbit := currentbit -1;
						state := state_send0;
				   else 
					   state := state_ack0;
				   end if;
				when state_ack0 =>
			      state := state_ack1;
				when state_ack1 =>
				   if SCL/='0' then  -- continue when not stretching the clock
  	         state := state_ack2;
			   	end if;
				when state_ack2 =>
				   if currentbyte < 2 then
					   currentbyte := currentbyte + 1;
						currentbit := 7;
						state := state_send0;
					else 
					   state := state_stop0;
				   end if;
				when state_stop0 =>
				   state := state_stop1;
				when state_stop1 =>
				   if SCL/='0' then -- continue when not stretching the clock
					   state := state_idle;
				   end if;
    		   when state_idle =>
	            if currentline < num-1 then
					   currentline := currentline+1;
		            state := state_start0;
					end if;		
	       	end case;
	      end if;  -- clock divider

			-- compute output registers 
			if state=state_start0 or state=state_start1 
			or state=state_stop0 or state=state_stop1 then
			   out_sda := '0';
			elsif state=state_send0 or state=state_send1 or state=state_send2 then
			   tmptripplet := DATA(currentline);
				tmp8 := to_unsigned(tmptripplet(currentbyte),8);
            out_sda := tmp8(currentbit);
 			else 
			   out_sda := '1';
         end if;
			if state=state_delay or state=state_idle or state=state_start0
			or state=state_send1 or state=state_ack1 or state=state_stop1 then
			  out_scl := '1';
			else 
			  out_scl := '0';
			end if;
			
		end if;   -- clock	

	   -- set output signals according to registers
		if out_scl='0' then
		   SCL <= '0';
		else 
		   SCL <= 'Z';
	   end if;
		if out_sda='0' then
		   SDA <= '0';
		else 
		   SDA <= 'Z';
	   end if;	
	end process;
	

	-- send initialization data to ADC via proprietary serial protocol
	process (clksample)
	  constant initdelay:integer := 100;
	  -- data to be sent 
	  constant num:integer := 6;	  
	  -- divide down main clock to get slower state machine clock
	  constant clockdivider:integer := 2000;  	  
	  variable clockcounter: integer range 0 to clockdivider-1 := 0;

	  -- states of the machine
	  subtype t_state is integer range 0 to 5;
	  constant state_delay  : integer := 0;
	  constant state_done   : integer := 1;
	  constant state_data   : integer := 2;
	  constant state_send   : integer := 3;
	  constant state_preparepulse  : integer := 4;
	  constant state_pulse  : integer := 5;
	  variable state : t_state := state_delay;

	  variable delaycounter:integer range 0 to initdelay-1 := 0;
	  variable currentline: integer range 0 to num-1;
	  variable currentbit:  integer range 0 to 13 := 0;
	  
	  -- registers for the output signals
	  variable out_sck : std_logic := '1';
	  variable out_sdi : std_logic := '1';
	  variable out_sen : std_logic := '1';
	  variable out_oeb : std_logic := '1';

	  -- temporary
	  variable tmp16 : unsigned(15 downto 0);
	  
	  begin
		if rising_edge(clksample) then
			
			-- process reset
			if RST='0' then
            state := state_delay;
				delaycounter := 0;
			
         -- divide input clock to get slower state machine clock
 		   elsif clockcounter+1<clockdivider then
		      clockcounter := clockcounter+1;

			else
			   clockcounter := 0;
				
				case state is
				when state_delay =>
					if delaycounter < initdelay-1 then
					   delaycounter := delaycounter+1;
				   else 
					   state := state_data;
						currentline := 0;
						currentbit := 13;
					end if;
				when state_data =>
				   state := state_send;
				when state_send =>
				   if currentbit > 0 then
					   currentbit := currentbit-1;
				      state := state_data;
				   else
					   state := state_preparepulse;
				   end if;
				when state_preparepulse =>
				   state := state_pulse;
				when state_pulse =>
	            if currentline < num-1 then
					   currentline := currentline+1;
						currentbit := 13;
   				   state := state_data;
					else 
					   state := state_done;
					end if;		
				when state_done =>
				end case;
	      end if;  -- clock divider

			-- compute output registers 
			if state=state_data or state=state_send then
			   case currentline is
				when 0 =>  tmp16 := to_unsigned(16#0400#, 16);  -- software reset
				when 1 =>  tmp16 := to_unsigned(16#0105#, 16);  -- EN=1, CDS=0, MONO=1
				when 2 =>  tmp16 := to_unsigned(16#0201#, 16);  -- OPFORM=(8 bit)  RLCDACRNG=0 to AVDD
				when 3 =>  tmp16 := to_unsigned(16#0307#, 16);  -- RLCDAC reference voltage
				when 4 =>  tmp16 := to_unsigned(16#2000#, 16);  -- Offset for channel A
				           tmp16(7 downto 3) := unsigned(SWITCH(9 downto 5));
				when 5 =>  tmp16 := to_unsigned(16#2800#, 16);  -- Gain cannel A
				           tmp16(4 downto 0) := unsigned(SWITCH(4 downto 0));
				end case;
            out_sdi := tmp16(currentbit);
 			else 
			   out_sdi := '0';
         end if;
			
			if state=state_send then
			  out_sck := '1';
			else 
			  out_sck := '0';
			end if;

			if state=state_pulse then
			  out_sen := '1';
			else 
			  out_sen := '0';
			end if;
			
			if state=state_done then
			   out_oeb := '0';
		   else
			   out_oeb := '1';
			end if;
			
		end if;   -- clock	

	   -- set output signals according to registers
		SCK <= out_sck;
		SDI <= out_sdi;
		SEN <= out_sen;
		OEB <= out_oeb;
	end process;
	

--	-- check for clocking of the input
--	process (clksample)
--	  variable counter: unsigned(17 downto 0);
--	begin
--		if rising_edge(clksample) then
--			counter := counter+1;
--		end if;
--		LED <= std_logic_vector(counter);
--	end process;
	
	
	
end immediate;


